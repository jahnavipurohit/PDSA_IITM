'''Quadratic probing is an open addressing scheme in computer programming 
for resolving hash collisions in hash tables. Quadratic probing operates by taking 
the original hash index and adding successive values of an arbitrary quadratic polynomial 
until an open or empty slot is found.
An example of a sequence using quadratic probing is:
h, h + 1, h + 4 ,h+9...h+i^ 2
Quadratic function
Let h(k) = k mod m be a hash function that maps an element k to an integer in [0, m-1], 
where m is the size of the table. Let the ith probe position for a value k be given by 
the function h(k, i) = (h(k) + c_{1}*i + c_{2} * i ^ 2) mod m where cl and c2 are positive integers. 
The value of 10, and increase this until we get one free slot in hash table. So we start from i = 0, 1 ,....=-1

For a given class Hashing, create two methods:
store_data(data): That accepts a positive integer data and 
generate an index value (0 to m-1) using given quadratic function and 
stores data in hashtable list on corresponding index generated by quadratic function. 
hashtable can contain only m data items. So, if all are already filled, 
then print Hash table is full.
display_hashtable(): That returns hashtable.'''

class Hashing:
  def __init__(self,c1,c2,m):
    self.hashtable = []
    for i in range(m):
        self.hashtable.append(None)     
    self.c1 = c1
    self.c2 = c2
    self.m = m

    self.num_elements = 0 # Keep track of filled slots to check if table is full

  def store_data(self, data):
    """
    Stores data in the hashtable using quadratic probing.
    """
    if self.num_elements == self.m:
      print("Hash table is full")
      return

    # Initial hash value: h(k) = k mod m
    initial_hash = data % self.m

    for i in range(self.m): # Probe up to m times
      # Quadratic probing formula: (h(k) + c1*i + c2*i^2) mod m
      probe_index = (initial_hash + self.c1 * i + self.c2 * (i**2)) % self.m

      if self.hashtable[probe_index] is None:
        self.hashtable[probe_index] = data
        self.num_elements += 1
        return
    
    # This point should ideally not be reached if num_elements check is perfect and m is prime
    # and load factor is low enough for full table detection, but as per problem,
    # if it runs out of slots after m probes (which implies full), print the message
    print("hash table is full")


  def display_hashtable(self):
    """
    Returns the current state of the hashtable.
    """
    return self.hashtable

c1 = int(input())
c2 = int(input())
m = int(input())
data=eval(input())
A = Hashing(c1,c2,m)
for i in data:
	A.store_data(i)
print(A.display_hashtable())